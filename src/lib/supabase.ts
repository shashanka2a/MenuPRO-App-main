import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://isletdfyulyiicpopcoq.supabase.co'
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlzbGV0ZGZ5dWx5aWljcG9wY29xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1NTg1MTUsImV4cCI6MjA3NjEzNDUxNX0.cYRyyf1oanH4ezfZJDfMKPh0KcQo57VwsADuywuMkaA'
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'your-service-role-key-here'

// Client for browser/client-side usage
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
})

// Admin client for server-side usage with service role key
export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})

// Database types (will be generated by Supabase CLI)
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: string
          email: string
          verified: boolean
          type: 'CUSTOMER' | 'RESTAURANT' | 'ADMIN'
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          email: string
          verified?: boolean
          type?: 'CUSTOMER' | 'RESTAURANT' | 'ADMIN'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          email?: string
          verified?: boolean
          type?: 'CUSTOMER' | 'RESTAURANT' | 'ADMIN'
          created_at?: string
          updated_at?: string
        }
      }
      restaurants: {
        Row: {
          id: string
          name: string
          email: string
          phone: string | null
          address: string | null
          city: string | null
          state: string | null
          zip_code: string | null
          cuisine: string | null
          description: string | null
          is_active: boolean
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          name: string
          email: string
          phone?: string | null
          address?: string | null
          city?: string | null
          state?: string | null
          zip_code?: string | null
          cuisine?: string | null
          description?: string | null
          is_active?: boolean
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          name?: string
          email?: string
          phone?: string | null
          address?: string | null
          city?: string | null
          state?: string | null
          zip_code?: string | null
          cuisine?: string | null
          description?: string | null
          is_active?: boolean
          created_at?: string
          updated_at?: string
        }
      }
      orders: {
        Row: {
          id: string
          order_number: string
          restaurant_id: string
          table_id: string | null
          customer_email: string
          status: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'COMPLETED' | 'CANCELLED'
          subtotal: number
          tax: number
          discount: number
          total: number
          estimated_time: string | null
          notes: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          order_number: string
          restaurant_id: string
          table_id?: string | null
          customer_email: string
          status?: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'COMPLETED' | 'CANCELLED'
          subtotal: number
          tax?: number
          discount?: number
          total: number
          estimated_time?: string | null
          notes?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          order_number?: string
          restaurant_id?: string
          table_id?: string | null
          customer_email?: string
          status?: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'COMPLETED' | 'CANCELLED'
          subtotal?: number
          tax?: number
          discount?: number
          total?: number
          estimated_time?: string | null
          notes?: string | null
          created_at?: string
          updated_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      user_type: 'CUSTOMER' | 'RESTAURANT' | 'ADMIN'
      order_status: 'PENDING' | 'CONFIRMED' | 'PREPARING' | 'READY' | 'COMPLETED' | 'CANCELLED'
    }
  }
}

// Helper functions for common Supabase operations
export class SupabaseHelpers {
  // Authentication helpers
  static async signUp(email: string, password: string) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    })
    return { data, error }
  }

  static async signIn(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    return { data, error }
  }

  static async signOut() {
    const { error } = await supabase.auth.signOut()
    return { error }
  }

  static async getCurrentUser() {
    const { data: { user }, error } = await supabase.auth.getUser()
    return { user, error }
  }

  // Real-time subscriptions
  static subscribeToOrders(restaurantId: string, callback: (payload: any) => void) {
    return supabase
      .channel('orders')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `restaurant_id=eq.${restaurantId}`
        },
        callback
      )
      .subscribe()
  }

  static subscribeToOrderStatus(orderId: string, callback: (payload: any) => void) {
    return supabase
      .channel('order-status')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'orders',
          filter: `id=eq.${orderId}`
        },
        callback
      )
      .subscribe()
  }

  // File storage helpers
  static async uploadFile(bucket: string, path: string, file: File) {
    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file)
    return { data, error }
  }

  static async getPublicUrl(bucket: string, path: string) {
    const { data } = supabase.storage
      .from(bucket)
      .getPublicUrl(path)
    return data.publicUrl
  }

  static async deleteFile(bucket: string, path: string) {
    const { data, error } = await supabase.storage
      .from(bucket)
      .remove([path])
    return { data, error }
  }

  // Database helpers using Supabase client
  static async getRestaurantOrders(restaurantId: string) {
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        order_items (
          *,
          menu_items (
            name,
            price
          )
        ),
        tables (
          table_number
        ),
        users (
          email
        )
      `)
      .eq('restaurant_id', restaurantId)
      .order('created_at', { ascending: false })

    return { data, error }
  }

  static async updateOrderStatus(orderId: string, status: string) {
    const { data, error } = await supabase
      .from('orders')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('id', orderId)
      .select()

    return { data, error }
  }

  static async getRestaurantMenu(restaurantId: string) {
    const { data, error } = await supabase
      .from('menus')
      .select(`
        *,
        menu_items (
          *,
          menu_item_options (
            *,
            option_values (*)
          ),
          menu_item_customizations (*)
        )
      `)
      .eq('restaurant_id', restaurantId)
      .eq('is_active', true)

    return { data, error }
  }

  // Analytics helpers
  static async getRestaurantAnalytics(restaurantId: string, startDate: string, endDate: string) {
    const { data, error } = await supabase
      .from('analytics')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: true })

    return { data, error }
  }
}

// Row Level Security (RLS) policies helper
export class RLSPolicies {
  // Enable RLS on all tables
  static async enableRLS() {
    const tables = [
      'users', 'restaurants', 'menus', 'menu_items', 'menu_item_options',
      'option_values', 'menu_item_customizations', 'tables', 'qr_codes',
      'orders', 'order_items', 'analytics', 'otp_verifications', 'operating_hours'
    ]

    for (const table of tables) {
      await supabaseAdmin.rpc('enable_rls', { table_name: table })
    }
  }

  // Create policies for restaurant data access
  static async createRestaurantPolicies() {
    // Restaurants can only access their own data
    await supabaseAdmin.rpc('create_policy', {
      table_name: 'restaurants',
      policy_name: 'restaurants_own_data',
      policy_definition: 'auth.uid() = user_id',
      policy_command: 'ALL'
    })

    // Similar policies for other tables...
  }
}

export default supabase
